import sys
import os
import time
import subprocess
import traceback

# ----- Import third-party libs with ImportError guard -----
try:
    import requests
    import pyautogui
    import pygetwindow as gw
except ImportError as e:
    sys.stderr.write(
        f"[FATAL] Missing dependency: {e.name}\n"
        "Run: pip install requests pyautogui pygetwindow\n"
    )
    sys.exit(1)

# ---------------- Configuration ----------------
OUTPUT_DIRECTORY = os.path.join(os.path.expanduser("~"), "Desktop", "tjm-project", "posts")
NUMBER_OF_POSTS = 10
NOTEPAD_LAUNCH_DELAY = 2.5
POST_TYPING_DELAY = 0.5
CHARACTER_TYPING_SPEED = 0.008

# Configure pyautogui safety feature
pyautogui.FAILSAFE = True  # Move mouse to corner to abort

# ---------------- Helper Functions ----------------
def create_output_directory():
    """Create the output directory if it doesn't exist."""
    try:
        os.makedirs(OUTPUT_DIRECTORY, exist_ok=True)
        print(f"[+] Output directory ready: {OUTPUT_DIRECTORY}")
    except OSError as error:
        sys.stderr.write(f"[FATAL] Cannot create output directory: {error}\n")
        sys.exit(1)

def terminate_all_notepad_instances():
    """Force-close all Notepad instances (safety cleanup)."""
    subprocess.run(["taskkill", "/F", "/IM", "notepad.exe"], capture_output=True, check=False)
    subprocess.run(["taskkill", "/F", "/IM", "Notepad.exe"], capture_output=True, check=False)

def fetch_blog_posts(post_limit=NUMBER_OF_POSTS):
    """Fetch blog posts from JSONPlaceholder API."""
    api_url = f"https://jsonplaceholder.typicode.com/posts?_limit={post_limit}"
    try:
        response = requests.get(api_url, timeout=10)
        response.raise_for_status()
        fetched_posts = response.json()
        print(f"[+] Successfully fetched {len(fetched_posts)} blog posts from API")
        return fetched_posts
    except requests.RequestException as network_error:
        print(f"[!] Network error while fetching posts: {network_error}")
        return []

def start_notepad_application():
    """Launch Notepad application and return the process object."""
    try:
        notepad_process = subprocess.Popen(
            ["notepad"], 
            stdout=subprocess.DEVNULL, 
            stderr=subprocess.DEVNULL
        )
        return notepad_process
    except FileNotFoundError:
        raise FileNotFoundError("Notepad executable not found. Is it installed or on PATH?")

def confirm_notepad_is_active():
    """Ensure the foreground window is Notepad before typing."""
    try:
        current_window = gw.getActiveWindow()
        if not current_window or "Notepad" not in current_window.title:
            raise RuntimeError("Active window is not Notepad. Typing operation aborted.")
    except Exception as focus_error:
        raise RuntimeError(f"Window focus verification failed: {focus_error}")

def type_content_safely(text_content):
    """Type text into the active window with error handling."""
    try:
        pyautogui.typewrite(text_content, interval=CHARACTER_TYPING_SPEED)
    except pyautogui.FailSafeException:
        raise RuntimeError("Typing operation aborted by user (pyautogui FAILSAFE triggered).")
    except Exception as typing_error:
        raise RuntimeError(f"Error during typing operation: {typing_error}")

def save_post_content_to_file(post_identifier, post_content):
    """Save the post content directly to a text file."""
    filename = os.path.join(OUTPUT_DIRECTORY, f"post_{post_identifier}.txt")
    try:
        with open(filename, "w", encoding="utf-8") as file_handle:
            file_handle.write(post_content)
        print(f"[+] Successfully saved: {os.path.basename(filename)}")
    except OSError as file_error:
        raise RuntimeError(f"File system error while saving '{filename}': {file_error}")

def format_blog_post_content(blog_post):
    """Format the blog post data into readable content."""
    post_title = blog_post.get('title', 'Untitled Post')
    post_body = blog_post.get('body', 'No content available')
    post_id = blog_post.get('id', 'unknown')
    
    formatted_content = f"""BLOG POST #{post_id}

TITLE: {post_title.title()}

CONTENT:
{post_body.capitalize()}

---
Generated by Automated Notepad Bot
Source: JSONPlaceholder API"""
    
    return formatted_content

# ---------------- Main Processing Function ----------------
def process_individual_blog_post(blog_post_data):
    """Process a single blog post: launch notepad, type content, save file, close notepad."""
    post_id = blog_post_data.get("id", "unknown")
    post_content = format_blog_post_content(blog_post_data)
    notepad_process = None
    
    try:
        # Step 1: Launch Notepad
        notepad_process = start_notepad_application()
        print(f"[+] Notepad launched successfully (Process ID: {notepad_process.pid})")
        time.sleep(NOTEPAD_LAUNCH_DELAY)

        # Step 2: Verify Notepad is in focus
        confirm_notepad_is_active()
        
        # Step 3: Type the blog post content
        print(f"[~] Typing content for blog post #{post_id}...")
        type_content_safely(post_content)

        # Step 4: Save content to file
        save_post_content_to_file(post_id, post_content)
        time.sleep(POST_TYPING_DELAY)
        
        print(f"[âœ“] Blog post #{post_id} processed successfully")

    except Exception as processing_error:
        print(f"[!] Error processing blog post #{post_id}: {processing_error}")
        traceback.print_exc()
    finally:
        # Step 5: Clean up - Close Notepad
        print(f"[~] Closing Notepad for blog post #{post_id}...")
        terminate_all_notepad_instances()
        
        # Also attempt to kill by process ID if still running
        if notepad_process and notepad_process.poll() is None:
            subprocess.run(
                ["taskkill", "/F", "/PID", str(notepad_process.pid)], 
                capture_output=True, 
                check=False
            )

def main():
    """Main execution function."""
    # Check if running on Windows
    if os.name != "nt":
        sys.stderr.write("[FATAL] This script is designed for Windows only.\n")
        sys.exit(1)

    print("=" * 60)
    print("    AUTOMATED NOTEPAD BLOG POST GENERATOR")
    print("=" * 60)
    
    # Initialize
    create_output_directory()
    terminate_all_notepad_instances()  # Clean start

    # Fetch blog posts from API
    blog_posts = fetch_blog_posts()
    if not blog_posts:
        print("[!] No blog posts were fetched. Exiting application.")
        return

    print(f"[+] Starting automation for {len(blog_posts)} blog posts...")
    print("[INFO] Move mouse to screen corner to abort if needed (FAILSAFE)\n")

    # Process each blog post
    for index, current_post in enumerate(blog_posts, 1):
        print(f"\n--- Processing Post {index}/{len(blog_posts)} ---")
        process_individual_blog_post(current_post)
        
        # Brief pause between posts
        if index < len(blog_posts):
            time.sleep(0.8)

    # Final cleanup
    terminate_all_notepad_instances()
    
    print("\n" + "=" * 60)
    print("    AUTOMATION COMPLETED SUCCESSFULLY!")
    print(f"    Check files in: {OUTPUT_DIRECTORY}")
    print("=" * 60)

# ---------------- Entry Point ----------------
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Process interrupted by user. Performing cleanup...")
        terminate_all_notepad_instances()
        sys.exit(1)
    except Exception as unexpected_error:
        print(f"[!] Unexpected error occurred: {unexpected_error}")
        traceback.print_exc()
        terminate_all_notepad_instances()
        sys.exit(1)